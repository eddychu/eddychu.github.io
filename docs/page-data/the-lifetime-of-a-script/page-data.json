{"componentChunkName":"component---src-templates-blog-post-js","path":"/the-lifetime-of-a-script/","result":{"data":{"site":{"siteMetadata":{"title":"Connecting Dots"}},"markdownRemark":{"id":"a93ce51f-410e-5baf-90fe-c87a7333b33b","excerpt":"Step 1: Loading the document Before the web browser starts parsing a web page, it will first creates a Document object. the document.readyState property is set…","html":"<h2>Step 1: Loading the document</h2>\n<p>Before the web browser starts parsing a web page, it will first creates a Document object. <strong><em>the document.readyState property is set to be loading</em></strong>. As the parser scan through the webpage, Dom Element objects will be added the the document object. </p>\n<p>When the HTML parser encounters a &#x3C;script> tag. Something interesting will happen here:</p>\n<h3>1. inline script</h3>\n<p>If it is an inline &#x3C;script> tag or &#x3C;script\\ src=\"\"> tag without async, defer, or type=“module” attributes, the script element are added to document just like any other dom element. It will also be exectued synchronously in the same order the parser encounters them. The script will have access to its own &#x3C;script> tag and document content that comes before itself.</p>\n<h3>2. async script</h3>\n<p>When the parser encounters a &#x3C;script> that has async attribute set, it begin downloading the script text and continues parsing the rest of document. After the script content is downloaded, it will be exectued. once it is downloaded they behave the same as the first scenario.</p>\n<p><em>Do note that it is highly possible that the parser might already parsed the whole document (might happen in step 2 or even step 3) by the time the async script is downloaded, in which case, the async script will have the whole access to the whole document object.</em></p>\n<h3>3. module script</h3>\n<p>a module script is a script with type=“module” attribute set. it behaves the same as async script, with one difference that when the browser begins downloading the script, it will also download all of the script’s dependencies. while the parser continues to parsing the document.</p>\n<h2>Step 2: document is parsed</h2>\n<p>When the document is completely parsed, <strong><em>the document.readyState property\nchanges to “interactive.”</em></strong></p>\n<p>At this phase, any script with defer attribute set (along with any module scripts that do not have an async attribute) are executed in the order in which they appeared\nin the document.Deferred\nscripts have access to the complete document</p>\n<h2>Step 3: document is ready</h2>\n<p>The browser fires a “DOMContentLoaded” event on the Document object. This\nmarks the transition from synchronous script-execution phase to the\nasynchronous, event-driven phase of program execution. only async script might still haven’t be exectued at this phase (might because of slow internet speed or script file too large so it takes too long to download)</p>\n<p>the browser may still be waiting for additional content, such as images, to load. When all such content finishes loading, and when all async scripts have loaded and executed, <strong><em>the document.readyState property changes to “complete” and the web browser fires\na “load” event on the Window object</em></strong>.</p>\n<p>From this point on, event handlers are invoked asynchronously in response to\nuser input events, network events, timer expirations, and so on.</p>\n<p>Reference: Javascript: The Definitive Guide, 7th Edition</p>","frontmatter":{"title":"The lifetime of a script","date":"October 31, 2020","description":null}},"previous":{"fields":{"slug":"/the-life-and-death-of-a-component/"},"frontmatter":{"title":"The life and death of a React Class Component"}},"next":null},"pageContext":{"id":"a93ce51f-410e-5baf-90fe-c87a7333b33b","previousPostId":"d5f0d4a0-d304-5efc-9b92-7187ee9e0f28","nextPostId":null}},"staticQueryHashes":["2841359383","916993862"]}