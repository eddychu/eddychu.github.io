<!DOCTYPE html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/css/a11y-light.css"><title>Connecting Dots | Blog By Eddy Chu</title><body> <h2><a href="/">Connecting Dots</a></h2><hr><h1>The life and death of a React Class Component</h1><p>If you were confused by React (Class) Component&#39;s life cycle methods, I hope this article will help you understand it better.</p>
<p>With a component approach, React turns frontend development to a simple question: render view based on current state. To acheive this, React provides us with a few methods to facilitate state and view management. These methods are the socalled life cycle method. They will be called by React runtime one after the other during the life cyle (mounting, updating, unmounting) of a React ClassComponent. </p>
<p>I will try to explain this with a few examples. you can also try it on <a href="https://codesandbox.io/s/component-lifecycle-j0jtn">codesandbox</a></p>
<h2 id="mounting--the-birth-of-a-react-component">Mounting : The birth of a React component</h2>
<p>Mounting is the first phase of the life cycle. It starts with the constructor of a component gets called. </p>
<pre><code class="language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> {
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.state = { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello world&quot;</span> };
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1: Message Constructor&quot;</span>);
  }

  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2: getDerivedStateFromProps&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3: render&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>{this.state.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }

  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4: componentDidMount&quot;</span>);
    <span class="hljs-comment">// console.log(document.getElementById(&quot;message&quot;))</span>
  }
}
</code></pre>
<p>In this example, the Message class constructor is the first method to be called. Then a static function getDerivedStateFromProps is called automatically to give us a chance to change the state based on initial props. With the execution of the render() function, the dom element gets added to the dom. Then React calls componentDidMount() function. After this, the real dom element created by Message is finally accessible.</p>
<h2 id="updating-a-change-of-state">Updating: A change of state</h2>
<p>Updating phase starts when the state changes, through this.setState() function. </p>
<pre><code class="language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.setState({ <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;goodbye!&quot;</span> });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;state changed, we need update now !!!!&quot;</span>);
  }

  <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5: shouldComponentUpdate&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6: render&quot;</span>);
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>
        {this.state.message}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7: componentDidUpdate&quot;</span>);
  }
}
</code></pre>
<p>After we click the component, handleClick function changes the message state. shouldComponentUpdate is called the next step. Notice that if this function returns false, the subsequent render would be canceled. Only when it returns true, render function gets called with the updated state. </p>
<h2 id="unmounting-time-to-say-goodbye">Unmounting: Time to say goodbye</h2>
<p>In unmounting phase, React component is destroyed and and removed from the dom tree. </p>
<pre><code class="language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7: unmount&quot;</span>);
  }
}

<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> [show, setShow] = useState(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {show &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Message</span> /&gt;</span>}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setShow((show) =&gt; !show)}&gt;toggle Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>));
</code></pre>
<p>in the code above, when show is set to be false, the last life cycle method componentWillUnmount will be called. <Message /> component then will be removed from the DOM tree.</p>
<p>As you can see, with a few life cycle methods, we have full control of a class component from birth to death. But if you were to start a new react project today, functional component is a much better choice. Because with in a functional component, these life cycle methods are replaced with a few even simpler &quot;hooks&quot;. I guess that will be our next topic. </p>
</body></head>